name: Codex Full Auto (with Self-Correction Loop)

on:
  workflow_dispatch:
    inputs:
      CODEX_PROMPT:
        description: 'The main instruction/prompt for the AI.'
        required: true
        default: 'Create a simple placeholder file.'
      TICKET_ID:
        description: 'The Jira/Ticket ID for branch naming and commits.'
        required: true
        default: 'default-ticket-id'
      CODEX_MODEL:
        description: 'The AI model to use (e.g., o3, gpt-4-turbo).'
        required: true
        default: 'o3'
      JIRA_IMAGE_URLS:
        description: 'Comma-separated list of image URLs from Jira.'
        required: false
      JIRA_IMAGE_FILENAMES:
        description: 'Comma-separated list of original image filenames from Jira.'
        required: false
  repository_dispatch:
    types: [codex-run]

jobs:
  codex-full-auto:
    runs-on: ubuntu-latest
    container: node:latest

    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
      N8N_MR_WEBHOOK_URL: ${{ secrets.N8N_PR_WEBHOOK_URL }}
      JIRA_API_USER: ${{ secrets.JIRA_API_USER }}
      JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
      CODEX_PUSH_TOKEN: ${{ secrets.CODEX_PUSH_TOKEN }}
      SCREENSHOTONE_API_KEY: ${{ secrets.SCREENSHOTONE_API_KEY }}
      CODEX_PROMPT: |
        ${{ github.event.inputs.CODEX_PROMPT || github.event.client_payload.CODEX_PROMPT }}
      TICKET_ID: ${{ github.event.inputs.TICKET_ID || github.event.client_payload.TICKET_ID }}
      CODEX_MODEL: ${{ github.event.inputs.CODEX_MODEL || github.event.client_payload.CODEX_MODEL }}
      JIRA_IMAGE_URLS: ${{ github.event.inputs.JIRA_IMAGE_URLS || github.event.client_payload.JIRA_IMAGE_URLS }}
      JIRA_IMAGE_FILENAMES: ${{ github.event.inputs.JIRA_IMAGE_FILENAMES || github.event.client_payload.JIRA_IMAGE_FILENAMES }}
      GH_REPO: ${{ github.repository }}
      DEFAULT_BRANCH: ${{ github.event.repository.default_branch }}
      AEM_URL: ${{ secrets.AEM_URL }}
      AEM_USERNAME: ${{ secrets.AEM_USERNAME }}
      AEM_PASSWORD: ${{ secrets.AEM_PASSWORD }}
      AEM_SRC_PATH: ${{ secrets.AEM_SRC_PATH }}
      AEM_DEST_PARENT_PATH: ${{ secrets.AEM_DEST_PARENT_PATH }}

    steps:
      - name: 1. Install System Dependencies
        run: apt-get update -y && apt-get install -y --no-install-recommends curl jq sed file
      - name: 2. Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ env.CODEX_PUSH_TOKEN }}
          fetch-depth: 0
      - name: 3. Configure Git and Install Codex CLI
        run: |
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions-bot@github.com"
          npm install -g @openai/codex
      - name: 4. Install Project Dependencies
        run: npm install
      - name: 5. Set Workspace Permissions for Non-Root User
        run: |
          chown -R node:node "$GITHUB_WORKSPACE"

      - name: 6. Execute Main AI, Build, and Git Logic
        id: main_script
        shell: bash
        env:
          DEMO_DATA_PROMPT: |
            ---
            **Additional Task: Create Demo Data**
            After creating the component files as requested above, you MUST ALSO perform the following action:
            1. Create a new file named `demo_data.json` inside the new component's directory.
            2. The content MUST be a single, raw JSON object.
            3. The keys must correspond to the `name` properties of the fields in the component's model file.
            4. Populate the JSON with realistic, high-quality demo content.
        run: |
          git config --global --add safe.directory "$GITHUB_WORKSPACE"
          FEATURE_BRANCH_NAME="feature/$TICKET_ID"
          git checkout -b "$FEATURE_BRANCH_NAME" "origin/$DEFAULT_BRANCH"
          FINAL_PROMPT="${CODEX_PROMPT}${DEMO_DATA_PROMPT}"
          CODEX_CMD_ARGS=("--full-auto" "-m" "$CODEX_MODEL")
          # (Image handling for initial creation)
          if [ -n "$JIRA_IMAGE_URLS" ] && [ "$JIRA_IMAGE_URLS" != "none" ]; then
            IFS=',' read -ra URL_ARRAY <<< "$JIRA_IMAGE_URLS"; IFS=',' read -ra FILENAME_ARRAY <<< "$JIRA_IMAGE_FILENAMES"
            for i in "${!URL_ARRAY[@]}"; do
              URL=$(echo "${URL_ARRAY[$i]}" | xargs); FILENAME=$(echo "${FILENAME_ARRAY[$i]}" | xargs | sed 's/[^a-zA-Z0-9._-]/_/g')
              if [ -z "$URL" ] || [ -z "$FILENAME" ]; then continue; fi
              DOWNLOAD_PATH="jira_dl_image_${i}_${FILENAME}"; HTTP_STATUS=$(curl -sSL -w "%{http_code}" -o "$DOWNLOAD_PATH" -u "${JIRA_API_USER}:${JIRA_API_TOKEN}" "$URL")
              if [ "$HTTP_STATUS" -eq 200 ] && [ -s "$DOWNLOAD_PATH" ]; then CODEX_CMD_ARGS+=("-i" "$DOWNLOAD_PATH"); fi
            done
          fi
          codex exec "${CODEX_CMD_ARGS[@]}" "$FINAL_PROMPT"
          rm -f jira_dl_image_*
          echo "Compiling EDS Models..."; npm run build:json; echo "EDS Models build completed."
          if [ -n "$(git status --porcelain)" ]; then
            git add -A; git commit -m "feat($TICKET_ID): Apply AI-generated changes [skip ci]"; git push -u origin "$FEATURE_BRANCH_NAME"
            echo "changes_pushed=true" >> $GITHUB_OUTPUT
          else
            echo "No file changes detected."; echo "changes_pushed=false" >> $GITHUB_OUTPUT
          fi

      - name: 7. Sanitize Ticket ID for AEM
        id: sanitize
        if: steps.main_script.outputs.changes_pushed == 'true'
        run: |
          SANITIZED_NAME=$(echo "${TICKET_ID}" | sed 's/\//-/g')
          echo "aem_page_name=$SANITIZED_NAME" >> $GITHUB_OUTPUT

      - name: 8. Wait for EDS Deployment
        if: steps.main_script.outputs.changes_pushed == 'true'
        run: "sleep 10"

      - name: 9. Create AEM Demo Page
        if: steps.main_script.outputs.changes_pushed == 'true'
        run: |
          curl --fail-with-body "${AEM_URL}/bin/wcmcommand" -u "${AEM_USERNAME}:${AEM_PASSWORD}" -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' --data-raw "_charset_=UTF-8&cmd=copyPage&srcPath=${AEM_SRC_PATH}&destParentPath=${AEM_DEST_PARENT_PATH}&before=&destName=${{ steps.sanitize.outputs.aem_page_name }}&shallow=false"

      - name: 10. Wait for AEM Repository to Settle
        if: steps.main_script.outputs.changes_pushed == 'true'
        run: |
          echo "Waiting 5 seconds for AEM to finalize page creation..."
          sleep 5

      - name: 11. Update AEM Page Title
        if: steps.main_script.outputs.changes_pushed == 'true'
        run: |
          curl --fail-with-body "${AEM_URL}${AEM_DEST_PARENT_PATH}/${{ steps.sanitize.outputs.aem_page_name }}/jcr:content" -u "${AEM_USERNAME}:${AEM_PASSWORD}" -H 'Content-Type: application/x-www-form-urlencoded; charset=UTF-8' --data-raw "jcr:title=${{ steps.sanitize.outputs.aem_page_name }}"

      - name: 12. Add New Component to AEM Page
        id: add_component_step
        if: steps.main_script.outputs.changes_pushed == 'true'
        shell: bash
        run: |
          # This is the fully corrected logic for adding the component to the page
          DEMO_FILE_PATH=$(git diff --name-only HEAD~1 HEAD | grep 'demo_data.json' | head -n 1)
          SOURCE_MODEL_FILE_PATH=$(git diff --name-only HEAD~1 HEAD | grep 'blocks/.*_.*.json' | head -n 1)
          if [ -z "$DEMO_FILE_PATH" ] || [ -z "$SOURCE_MODEL_FILE_PATH" ]; then exit 0; fi
          COMPONENT_NAME=$(basename "$(dirname "$DEMO_FILE_PATH")")
          COMPILED_MODELS_FILE="component-models.json"
          ALL_FIELDS_JSON=$(jq -r --arg compName "$COMPONENT_NAME" '[.[] | select(.id == $compName) | .fields[].name] | unique' "$COMPILED_MODELS_FILE")
          MODEL_FIELDS_JSON_ARRAY=$(echo "$ALL_FIELDS_JSON" | jq '[.[] | select(. as $name | $name != "custom-button-link" and $name != "custom-button-target")]')
          NAME_VAL=$(jq -r '.definitions[0].title' "$SOURCE_MODEL_FILE_PATH")
          METADATA_JSON=$(jq -n --arg filter "$COMPONENT_NAME" --arg model "$COMPONENT_NAME" --arg name "$NAME_VAL" --argjson modelFields "$MODEL_FIELDS_JSON_ARRAY" '{filter: $filter, model: $model, name: $name, modelFields: $modelFields}')
          AI_CONTENT_JSON=$(cat "$DEMO_FILE_PATH")
          IMAGE_FIELD_NAME=$(jq -r --arg compName "$COMPONENT_NAME" '.[] | select(.id == $compName) | .fields[] | select(.component == "reference") | .name' "$COMPILED_MODELS_FILE" | head -n 1)
          FINAL_JSON=$(jq -n --argjson ai_content "$AI_CONTENT_JSON" --argjson meta "$METADATA_JSON" '$ai_content + $meta' | jq --arg fieldName "$IMAGE_FIELD_NAME" 'if $fieldName and $fieldName != "" then .[$fieldName] = "/content/dam/aco/content-at-scale.png" else . end')
          FORM_DATA=$(echo "$FINAL_JSON" | jq -r 'to_entries | .[] | if .value | type == "array" then .key as $k | .value[] | ($k|@uri) + "=" + (. | @uri) else (.key|@uri) + "=" + (.value|tostring|@uri) end' | paste -sd'&')
          SLING_RESOURCETYPE="core/franklin/components/block/v1/block"
          FINAL_FORM_DATA="${FORM_DATA}&sling:resourceType=${SLING_RESOURCETYPE}"
          AEM_PAGE_NAME="${{ steps.sanitize.outputs.aem_page_name }}"
          TARGET_URL="${AEM_URL}${AEM_DEST_PARENT_PATH}/${AEM_PAGE_NAME}/jcr:content/root/section_0/block"
          curl -v --fail-with-body "$TARGET_URL" -u "${AEM_USERNAME}:${AEM_PASSWORD}" -H "Content-Type: application/x-www-form-urlencoded; charset=UTF-8" --data-raw "$FINAL_FORM_DATA"

      - name: 13. Review, Fix, and Validate Loop
        id: review_loop
        if: steps.main_script.outputs.changes_pushed == 'true'
        shell: bash
        env:
          REVIEW_PROMPT_TEMPLATE: |
            You are a Senior Developer performing a QA check. Review the code, HTML, and screenshots.
            If perfect, respond ONLY with the word: PERFECT
            If buggy, provide the necessary code changes to fix it. Update demo_data.json if needed.

            Initial Requirements:
            %CODEX_PROMPT%

            Code:
            %CODE_CONTEXT%

            Live DOM:
            %SCRAPED_DOM%
        run: |
          set -e
          # --- CORRECTED: All variables are now defined inside the run block ---
          REVIEW_PASSED=false
          FEATURE_BRANCH_NAME="feature/$TICKET_ID"
          AEM_PAGE_NAME="${{ steps.sanitize.outputs.aem_page_name }}"
          PREVIEW_URL="${AEM_URL}${AEM_DEST_PARENT_PATH}/${AEM_PAGE_NAME}.html?ref=${FEATURE_BRANCH_NAME}"
          ENCODED_URL=$(jq -rn --arg url "$PREVIEW_URL" '$url|@uri')
          AUTH_HEADER=$(echo -n "${AEM_USERNAME}:${AEM_PASSWORD}" | base64)
          TARGET_BLOCK_URL="${AEM_URL}${AEM_DEST_PARENT_PATH}/${AEM_PAGE_NAME}/jcr:content/root/section_0/block"

          for i in 1 2; do
            echo "--- Starting Review Cycle #$i ---"
            SCRAPED_DOM=$(curl -s -u "${AEM_USERNAME}:${AEM_PASSWORD}" "$PREVIEW_URL")
            CHANGED_FILES=$(git diff --name-only "origin/$DEFAULT_BRANCH" HEAD)
            CODE_CONTEXT=""; for FILE in $CHANGED_FILES; do CODE_CONTEXT+="--- START: $FILE ---\n$(cat "$FILE")\n--- END: $FILE ---\n\n"; done
            
            REVIEW_CMD_ARGS=("--full-auto" "-m" "$CODEX_MODEL")
            curl -o "desktop-screenshot.jpg" "https://api.screenshotone.com/take?access_key=${SCREENSHOTONE_API_KEY}&url=${ENCODED_URL}&format=jpg&timeout=60&authorization=Basic ${AUTH_HEADER}"
            curl -o "mobile-screenshot.jpg" "https://api.screenshotone.com/take?access_key=${SCREENSHOTONE_API_KEY}&url=${ENCODED_URL}&viewport_device=iphone_11_pro&format=jpg&timeout=60&authorization=Basic ${AUTH_HEADER}"
            REVIEW_CMD_ARGS+=("-i" "desktop-screenshot.jpg" "-i" "mobile-screenshot.jpg")

            if [ -n "$JIRA_IMAGE_URLS" ] && [ "$JIRA_IMAGE_URLS" != "none" ]; then
              IFS=',' read -ra URL_ARRAY <<< "$JIRA_IMAGE_URLS"; IFS=',' read -ra FILENAME_ARRAY <<< "$JIRA_IMAGE_FILENAMES"
              for j in "${!URL_ARRAY[@]}"; do
                URL=$(echo "${URL_ARRAY[$j]}" | xargs); FILENAME=$(echo "${FILENAME_ARRAY[$j]}" | xargs | sed 's/[^a-zA-Z0-9._-]/_/g')
                if [ -z "$URL" ] || [ -z "$FILENAME" ]; then continue; fi
                DOWNLOAD_PATH="jira_review_image_${j}_${FILENAME}"; HTTP_STATUS=$(curl -sSL -w "%{http_code}" -o "$DOWNLOAD_PATH" -u "${JIRA_API_USER}:${JIRA_API_TOKEN}" "$URL")
                if [ "$HTTP_STATUS" -eq 200 ] && [ -s "$DOWNLOAD_PATH" ]; then REVIEW_CMD_ARGS+=("-i" "$DOWNLOAD_PATH"); fi
              done
            fi
            
            FINAL_REVIEW_PROMPT="${REVIEW_PROMPT_TEMPLATE/'%CODEX_PROMPT%'/"$CODEX_PROMPT"}"
            FINAL_REVIEW_PROMPT="${FINAL_REVIEW_PROMPT/'%CODE_CONTEXT%'/"$CODE_CONTEXT"}"
            FINAL_REVIEW_PROMPT="${FINAL_REVIEW_PROMPT/'%SCRAPED_DOM%'/"$SCRAPED_DOM"}"

            codex exec "${REVIEW_CMD_ARGS[@]}" "$FINAL_REVIEW_PROMPT" 2> codex_output.log
            rm -f desktop-screenshot.jpg mobile-screenshot.jpg jira_review_image_*

            if grep -q "PERFECT" codex_output.log; then
              echo "--- Review Passed! ---"; REVIEW_PASSED=true; break
            else
              echo "--- Review Failed. AI has provided fixes. ---"
              if [ -n "$(git status --porcelain)" ]; then
                git add -A; git commit -m "feat($TICKET_ID): Apply AI bug fixes (Attempt $i)"; git push
                echo "Waiting for fixes to deploy..."; sleep 20
                echo "Deleting and recreating AEM block...";
                curl -u "${AEM_USERNAME}:${AEM_PASSWORD}" -X POST -F':operation=delete' "$TARGET_BLOCK_URL"
                sleep 5
                bash -c "$(sed -n '/- name: 12. Add New Component to AEM Page/,/^      - name:/p' "$GITHUB_ACTION_PATH" | sed '$d' | tail -n +3)"
              else
                echo "AI suggested fixes, but no file changes were made. Assuming review passed."; REVIEW_PASSED=true; break
              fi
            fi
          done
          
          if [ "$REVIEW_PASSED" = true ]; then echo "validation_status=success" >> $GITHUB_OUTPUT; else echo "validation_status=failed" >> $GITHUB_OUTPUT; fi

      - name: 14. Notify N8N to Create Pull Request
        if: steps.review_loop.outputs.validation_status == 'success'
        shell: bash
        run: |
          FEATURE_BRANCH_NAME="feature/$TICKET_ID"; LATEST_COMMIT_SHA=$(git rev-parse HEAD); REPO_OWNER=$(echo "$GH_REPO" | cut -d'/' -f1); REPO_NAME=$(echo "$GH_REPO" | cut -d'/' -f2); SANITIZED_BRANCH_NAME=$(echo "$FEATURE_BRANCH_NAME" | sed 's/\//-/g'); PREVIEW_URL="https://$SANITIZED_BRANCH_NAME--$REPO_NAME--$REPO_OWNER.hlx.page"; PR_TITLE="feat($TICKET_ID): Implement feature $TICKET_ID (AI Assisted)"; PR_BODY=$(cat <<EOF
          This Pull Request was automatically generated by the Codex AI Developer to implement ticket **$TICKET_ID**.
          ### URL for testing:
          - $PREVIEW_URL
          Commit SHA: \`$LATEST_COMMIT_SHA\`
          EOF
          ); JSON_PAYLOAD=$(jq -n --arg fb "$FEATURE_BRANCH_NAME" --arg tb "$DEFAULT_BRANCH" --arg tid "$TICKET_ID" --arg commitSha "$LATEST_COMMIT_SHA" --arg repo "$GH_REPO" --arg prTitle "$PR_TITLE" --arg prBody "$PR_BODY" '{source_branch: $fb, target_branch: $tb, ticket_id: $tid, commit_sha: $commitSha, repo: $repo, pull_request_title: $prTitle, pull_request_body: $prBody}'); if [ -z "$N8N_MR_WEBHOOK_URL" ]; then echo "Warning: N8N_PR_WEBHOOK_URL secret is not set."; else curl -s -o /dev/null -w "%{http_code}" -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" "$N8N_MR_WEBHOOK_URL"; fi
